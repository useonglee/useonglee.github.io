<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>TIL #3 - 꿈을 기록하는 Blog</title>
<meta name="description" content="1. shuffle 메서드 설명     shuffle 레퍼런스 설명 :   아래 shuffle 레퍼런스 코드에 대해서 최대한 자세히 설명해주세요!     코드를 한 줄씩 설명해보세요. (코드의 각 키워드가 무슨 의미인지 한 번 되돌아봅시다.)   이 메서드의 작동 원리에 대해서 설명해주세요.   필요한 경우가 어떤 경우가 있을지 고민하여 하나의 예를 들어주세요.      :point_right: reference code   _.shuffle = function (arr) {   let arrCloned = arr.slice();   for (let fromIdx = 0; fromIdx &lt; arr.length; fromIdx++) {     const toIdx = Math.floor(Math.random() * arr.length);     let temp = arrCloned[fromIdx];     arrCloned[fromIdx] = arrCloned[toIdx];     arrCloned[toIdx] = temp;   }   return arrCloned; };   shuffle 메서드는 배열 요소의 순서가 랜덤하게 변경된 새로운 배열을 리턴한다.  다양한 상황 (ex. 비디오 또는 음악 재생의 순서를 섞을 때) 에서 유용하게 쓰일 수 있다.  그러면 본격적으로 코드를 설명하기위해 한 줄씩 파헤쳐보자 !     :point_right: code   let arrCloned = arr.slice();  arrCloned 이라는 변수에 얕은 복사를 통하여 배열을 가져왔다. 여기서 중요한 점은 slice() 는 원본을 대체하지 않는 점, 즉 원본은 따로 있다는 뜻이다.  String 및 Number 객체 가 아닌 경우 문자열과 숫자는 새 배열에 복사한다. 이 새 배열에서는 마음대로 값을 바꿔도 원본에 아무런 영향을 주지 않는 다는 점을 명심하자.   for (let fromIdx = 0; fromIdx &lt; arr.length; fromIdx++) {   주어진 배열의 요소를 확인하기 위해 for loop 를 사용하였다. 일반적인 배열 반복문이다.  const toIdx = Math.floor(Math.random() * arr.length);   이부분에서 특히 random() 메서드가 생소해서 많이 찾아봤던 것 같다. 먼저 ranmdom() 메서드는 0이상 1 미만의 부동소숫점 의사 난수를 반환 값으로 한다. 그렇기때문에 앞에 floor(반버림) 메서드를 사용하여 정수인 난수를 생성한다고 보면 될 것 같다. round(반올림) 메서드를 사용할 수 도 있지만, 이렇게 하면 난수가 고르게 분포하지 않게 된다.  random() 메서드에 배열의 길이(arr.length)를 곱해준 이유는 배열의 길이에 가까운 임의의 정수를 생성하기 위함인 것 같다.  let temp = arrCloned[fromIdx];   얕은복사를 통해 가져온 배열의 요소를 temp라는 변수에 할당을 한다. 할당을 한 이유에 대해서는 밑에서 설명한다.  다음 코드를 넘어가기 전에 배열 비구조화 할당 문법을 충분히 이해를 하고 가자. 이해를 돕기 위해 먼저 간단한 코드를 예시로 든다.  const array = [1, 2]; const [one, two] = array;  console.log(one);  // 1 console.log(two);  // 2  이 문법은 배열 안에 있는 원소를 다른 이름으로 새로 선언해주고 싶을 때 사용하면 매우 유용하다.  arrCloned[fromIdx] = arrCloned[toIdx]; arrCloned[toIdx] = temp;   이 코드를 설명하기 위해 먼저 arrCloned = [1, ‘a’, 2, ‘b’] 라는 배열이라고 가정하자. 반복문을 통해 첫번째 i 는 arrCloned[0] 가 될 것이고 값은 1 이다. toIdx는 random() 메서드를 통해 임의로 3의 정수가 나왔다고 가정하자. 위에 코드는  arrCloned[0] = arrCloned[3]; arrCloned[3] = temp (arrCloned[fromIdx] 변수를 할당한 이유); 이렇게 반복문을 한 번 돌고 나면 배열은 [‘b’, ‘a’, 2, 1] 이라는 값으로 임의로 변하게 된다. 이런 식으로 반복문을 다 돌고나면 랜덤하게 변경된 새로운 배열 값이 나올 것 이다.이 부분이 shuffle 메서드의 핵심인 것 같다.  return arrCloned;  그리고 반복문을 다돌고 새로 배열된 배열 값을 리턴(반환) 해준다.  이 공부를 통해 shuffle 메서드를 완벽히 짚고 넘어갈 수 있게 되었다. 얕은 복사를 통해 랜덤하게 배열을 섞을 때 사용하면 유용한 메서드라고 생각한다. 앞서 설명했듯이 음악 재생을 랜덤으로 돌릴 때나 무작위로 섞고 싶을 때 사용하면 유용할 것 같다.      2. 객체 21번     객체 문제 :   문자열을 입력받아 가장 많이 반복되는 문자를 리턴해야 합니다.     주의사항 :            띄어쓰기는 제외       가장 많이 반복되는 문자가 다수일 경우, 먼저 도달한 문자를 리턴       빈 문자열을 입력받은 경우, 빈 문자열을 리턴           입출력 예시   let output = mostFrequentCharacter(&#39;apples not oranges&#39;); console.log(output); // --&gt; &#39;p&#39;  output = mostFrequentCharacter(&#39;hello world&#39;); console.log(output); // --&gt; &#39;l&#39;      pseudocode(수도코드)            문자열을 반복문으로 순회를 하면서 어떤 문자가 가장 많이 반복되는지 카운트를 세어주어야 한다.       리턴되는 값은 문자열이기 때문에 문자열도 같이 할당한다.       반복문으로 문자열을 순회하면서, 띄어쓰기는 건너뛰고 객체에 key 값과 value값을 할당한다.       반복문으로 문자열을 순회하면서, 반복되는 문자열을 카운트해준다.       가장 많이 카운트 된 문자를 가져온다.       비구조화 할당을 통해 가장 많이 반복된 문자를 할당한다.       할당된 객체를 리턴한다.           let obj = {max: 0, countStr: &#39;&#39;};     for (let i = 0; i &lt; str.length; i++) {      if (str[i] === &#39; &#39;) {        continue;      }      if (obj[str[i]] === undefined) {        obj[str[i]] = 0;      }      obj[str[i]]++;    if (obj[&#39;max&#39;] &lt; obj[str[i]]) {      obj[&#39;max&#39;] = obj[str[i]];      obj[&#39;countStr&#39;] = str[i];    }   }    return obj[&#39;countStr&#39;];   이 문제의 핵심은 먼저 카운트를 할 객체를 할당하고, 카운트가 된 값을 비구조화 할당으로 가져오는 것이다. 나는 이 문제를 풀 때 처음에는 max = str[0] 로 할당하고 max 값의 문자를 반환하려고 했다. 오랜 삽질 끝에    let obj = {};   let max = str[0];    if(str === &#39;&#39;) {         return &#39;&#39;;   }    for(let i = 0; i &lt; str.length; i++) {     if(str[i] === &#39; &#39;) {                             continue;                                 }                                         else if(obj[str[i]] === undefined) {             obj[str[i]] = 0;     }     obj[str[i]]++;         if(obj[max] &lt; obj[str[i]]) {              obj[str[i]];                    max = str[i];           }   }        if( Object.keys(obj).length === 0 ) {      return &#39;&#39;;    }        return max;         이 코드로 문제를 풀어보기도 했다. 하지만 이 삽질이 결국 HA 시험에 큰 도움이 되었다. HA 시험 1번 문제를 가볍게 풀 수 있었다.      3. 고차함수 31번    고차함수 문제 :   아래 조건에 맞게 변형된 배열을 리턴해야 합니다.     주의사항 :            반복문 사용 금지       배열을 리턴       학생들의 성적을 평균값으로 변형해야 합니다.           입출력 예시   let studentList = [   {     name: &#39;Anna&#39;,     gender: &#39;female&#39;,     grades: [4.5, 3.5, 4],   },   {     name: &#39;Dennis&#39;,     gender: &#39;male&#39;,     country: &#39;Germany&#39;,     grades: [5, 1.5, 4],   },   {     name: &#39;Martha&#39;,     gender: &#39;female&#39;,     grades: [5, 4, 4, 3],   }, ];  console.log(output); // --&gt; [   { name: &#39;Anna&#39;, gender: &#39;female&#39;, grades: 4 },   { name: &#39;Martha&#39;, gender: &#39;female&#39;, grades: 4 }, ];      pseudocode(수도코드)            먼저 value 값이 ‘female’ 인 것만 필터링을 한다.       변형된 값을 반환하기 위해 맵핑을 하며 리턴을 한다.       평균 값을 구하기 위해 reduce 함수를 사용한다.       구한 평균값을 객체에 할당해준다.       객체를 리턴(반환)한다.             const filtering = students.filter (el =&gt; el.gender === &#39;female&#39;);    return filtering.map (function (el) {     const average = el.grades.reduce (function (acc, cur) {       return acc + cur;     }, 0);      const grade = average / el.grades.length;     el.grades = grade;          return el;   });   각 함수의 뜻을 정확히 이해하면 쉽게 풀 수 있는 문제였다. 함수를 하나씩 차근 차근 써가면서 내려가보니 답을 찾을 수 있었다.하지만 이 문제 또한 삽질을 안 한건 아니다. 매개변수 el 값을 계속 가져오면서 마지막에 평균 값을 할당하는 것이 막혔었다. 원리를 하나씩 짚어보며 풀어가다보니 해결할 수 있었다.     :punch: 내일의 TIW(today I Will)   재귀함수, 알고리즘">


  <meta name="author" content="이우성">
  
  <meta property="article:author" content="이우성">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="꿈을 기록하는 Blog">
<meta property="og:title" content="TIL #3">
<meta property="og:url" content="http://localhost:4000/2021/01/TIL3/">


  <meta property="og:description" content="1. shuffle 메서드 설명     shuffle 레퍼런스 설명 :   아래 shuffle 레퍼런스 코드에 대해서 최대한 자세히 설명해주세요!     코드를 한 줄씩 설명해보세요. (코드의 각 키워드가 무슨 의미인지 한 번 되돌아봅시다.)   이 메서드의 작동 원리에 대해서 설명해주세요.   필요한 경우가 어떤 경우가 있을지 고민하여 하나의 예를 들어주세요.      :point_right: reference code   _.shuffle = function (arr) {   let arrCloned = arr.slice();   for (let fromIdx = 0; fromIdx &lt; arr.length; fromIdx++) {     const toIdx = Math.floor(Math.random() * arr.length);     let temp = arrCloned[fromIdx];     arrCloned[fromIdx] = arrCloned[toIdx];     arrCloned[toIdx] = temp;   }   return arrCloned; };   shuffle 메서드는 배열 요소의 순서가 랜덤하게 변경된 새로운 배열을 리턴한다.  다양한 상황 (ex. 비디오 또는 음악 재생의 순서를 섞을 때) 에서 유용하게 쓰일 수 있다.  그러면 본격적으로 코드를 설명하기위해 한 줄씩 파헤쳐보자 !     :point_right: code   let arrCloned = arr.slice();  arrCloned 이라는 변수에 얕은 복사를 통하여 배열을 가져왔다. 여기서 중요한 점은 slice() 는 원본을 대체하지 않는 점, 즉 원본은 따로 있다는 뜻이다.  String 및 Number 객체 가 아닌 경우 문자열과 숫자는 새 배열에 복사한다. 이 새 배열에서는 마음대로 값을 바꿔도 원본에 아무런 영향을 주지 않는 다는 점을 명심하자.   for (let fromIdx = 0; fromIdx &lt; arr.length; fromIdx++) {   주어진 배열의 요소를 확인하기 위해 for loop 를 사용하였다. 일반적인 배열 반복문이다.  const toIdx = Math.floor(Math.random() * arr.length);   이부분에서 특히 random() 메서드가 생소해서 많이 찾아봤던 것 같다. 먼저 ranmdom() 메서드는 0이상 1 미만의 부동소숫점 의사 난수를 반환 값으로 한다. 그렇기때문에 앞에 floor(반버림) 메서드를 사용하여 정수인 난수를 생성한다고 보면 될 것 같다. round(반올림) 메서드를 사용할 수 도 있지만, 이렇게 하면 난수가 고르게 분포하지 않게 된다.  random() 메서드에 배열의 길이(arr.length)를 곱해준 이유는 배열의 길이에 가까운 임의의 정수를 생성하기 위함인 것 같다.  let temp = arrCloned[fromIdx];   얕은복사를 통해 가져온 배열의 요소를 temp라는 변수에 할당을 한다. 할당을 한 이유에 대해서는 밑에서 설명한다.  다음 코드를 넘어가기 전에 배열 비구조화 할당 문법을 충분히 이해를 하고 가자. 이해를 돕기 위해 먼저 간단한 코드를 예시로 든다.  const array = [1, 2]; const [one, two] = array;  console.log(one);  // 1 console.log(two);  // 2  이 문법은 배열 안에 있는 원소를 다른 이름으로 새로 선언해주고 싶을 때 사용하면 매우 유용하다.  arrCloned[fromIdx] = arrCloned[toIdx]; arrCloned[toIdx] = temp;   이 코드를 설명하기 위해 먼저 arrCloned = [1, ‘a’, 2, ‘b’] 라는 배열이라고 가정하자. 반복문을 통해 첫번째 i 는 arrCloned[0] 가 될 것이고 값은 1 이다. toIdx는 random() 메서드를 통해 임의로 3의 정수가 나왔다고 가정하자. 위에 코드는  arrCloned[0] = arrCloned[3]; arrCloned[3] = temp (arrCloned[fromIdx] 변수를 할당한 이유); 이렇게 반복문을 한 번 돌고 나면 배열은 [‘b’, ‘a’, 2, 1] 이라는 값으로 임의로 변하게 된다. 이런 식으로 반복문을 다 돌고나면 랜덤하게 변경된 새로운 배열 값이 나올 것 이다.이 부분이 shuffle 메서드의 핵심인 것 같다.  return arrCloned;  그리고 반복문을 다돌고 새로 배열된 배열 값을 리턴(반환) 해준다.  이 공부를 통해 shuffle 메서드를 완벽히 짚고 넘어갈 수 있게 되었다. 얕은 복사를 통해 랜덤하게 배열을 섞을 때 사용하면 유용한 메서드라고 생각한다. 앞서 설명했듯이 음악 재생을 랜덤으로 돌릴 때나 무작위로 섞고 싶을 때 사용하면 유용할 것 같다.      2. 객체 21번     객체 문제 :   문자열을 입력받아 가장 많이 반복되는 문자를 리턴해야 합니다.     주의사항 :            띄어쓰기는 제외       가장 많이 반복되는 문자가 다수일 경우, 먼저 도달한 문자를 리턴       빈 문자열을 입력받은 경우, 빈 문자열을 리턴           입출력 예시   let output = mostFrequentCharacter(&#39;apples not oranges&#39;); console.log(output); // --&gt; &#39;p&#39;  output = mostFrequentCharacter(&#39;hello world&#39;); console.log(output); // --&gt; &#39;l&#39;      pseudocode(수도코드)            문자열을 반복문으로 순회를 하면서 어떤 문자가 가장 많이 반복되는지 카운트를 세어주어야 한다.       리턴되는 값은 문자열이기 때문에 문자열도 같이 할당한다.       반복문으로 문자열을 순회하면서, 띄어쓰기는 건너뛰고 객체에 key 값과 value값을 할당한다.       반복문으로 문자열을 순회하면서, 반복되는 문자열을 카운트해준다.       가장 많이 카운트 된 문자를 가져온다.       비구조화 할당을 통해 가장 많이 반복된 문자를 할당한다.       할당된 객체를 리턴한다.           let obj = {max: 0, countStr: &#39;&#39;};     for (let i = 0; i &lt; str.length; i++) {      if (str[i] === &#39; &#39;) {        continue;      }      if (obj[str[i]] === undefined) {        obj[str[i]] = 0;      }      obj[str[i]]++;    if (obj[&#39;max&#39;] &lt; obj[str[i]]) {      obj[&#39;max&#39;] = obj[str[i]];      obj[&#39;countStr&#39;] = str[i];    }   }    return obj[&#39;countStr&#39;];   이 문제의 핵심은 먼저 카운트를 할 객체를 할당하고, 카운트가 된 값을 비구조화 할당으로 가져오는 것이다. 나는 이 문제를 풀 때 처음에는 max = str[0] 로 할당하고 max 값의 문자를 반환하려고 했다. 오랜 삽질 끝에    let obj = {};   let max = str[0];    if(str === &#39;&#39;) {         return &#39;&#39;;   }    for(let i = 0; i &lt; str.length; i++) {     if(str[i] === &#39; &#39;) {                             continue;                                 }                                         else if(obj[str[i]] === undefined) {             obj[str[i]] = 0;     }     obj[str[i]]++;         if(obj[max] &lt; obj[str[i]]) {              obj[str[i]];                    max = str[i];           }   }        if( Object.keys(obj).length === 0 ) {      return &#39;&#39;;    }        return max;         이 코드로 문제를 풀어보기도 했다. 하지만 이 삽질이 결국 HA 시험에 큰 도움이 되었다. HA 시험 1번 문제를 가볍게 풀 수 있었다.      3. 고차함수 31번    고차함수 문제 :   아래 조건에 맞게 변형된 배열을 리턴해야 합니다.     주의사항 :            반복문 사용 금지       배열을 리턴       학생들의 성적을 평균값으로 변형해야 합니다.           입출력 예시   let studentList = [   {     name: &#39;Anna&#39;,     gender: &#39;female&#39;,     grades: [4.5, 3.5, 4],   },   {     name: &#39;Dennis&#39;,     gender: &#39;male&#39;,     country: &#39;Germany&#39;,     grades: [5, 1.5, 4],   },   {     name: &#39;Martha&#39;,     gender: &#39;female&#39;,     grades: [5, 4, 4, 3],   }, ];  console.log(output); // --&gt; [   { name: &#39;Anna&#39;, gender: &#39;female&#39;, grades: 4 },   { name: &#39;Martha&#39;, gender: &#39;female&#39;, grades: 4 }, ];      pseudocode(수도코드)            먼저 value 값이 ‘female’ 인 것만 필터링을 한다.       변형된 값을 반환하기 위해 맵핑을 하며 리턴을 한다.       평균 값을 구하기 위해 reduce 함수를 사용한다.       구한 평균값을 객체에 할당해준다.       객체를 리턴(반환)한다.             const filtering = students.filter (el =&gt; el.gender === &#39;female&#39;);    return filtering.map (function (el) {     const average = el.grades.reduce (function (acc, cur) {       return acc + cur;     }, 0);      const grade = average / el.grades.length;     el.grades = grade;          return el;   });   각 함수의 뜻을 정확히 이해하면 쉽게 풀 수 있는 문제였다. 함수를 하나씩 차근 차근 써가면서 내려가보니 답을 찾을 수 있었다.하지만 이 문제 또한 삽질을 안 한건 아니다. 매개변수 el 값을 계속 가져오면서 마지막에 평균 값을 할당하는 것이 막혔었다. 원리를 하나씩 짚어보며 풀어가다보니 해결할 수 있었다.     :punch: 내일의 TIW(today I Will)   재귀함수, 알고리즘">







  <meta property="article:published_time" content="2021-01-12T00:00:00+09:00">






<link rel="canonical" href="http://localhost:4000/2021/01/TIL3/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="꿈을 기록하는 Blog Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          꿈을 기록하는 Blog
          <span class="site-subtitle">since 2021</span>
        </a>
        <ul class="visible-links">
<li class="masthead__menu-item">
              <a href="/posts/">TIL</a>
            </li>
<li class="masthead__menu-item">
              <a href="/categories/">Monthly</a>
            </li>
<li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li>
<li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li>
</ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/20201205_010626.jpg" alt="이우성" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">이우성</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>JavaScript기반 개발공부<br><br> 코드스테이츠 Full pre 10기</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="https://github.com/useonglee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
            <li><a href="mailto:useong0830@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="TIL #3">
    <meta itemprop="description" content="1. shuffle 메서드 설명  shuffle 레퍼런스 설명 :아래 shuffle 레퍼런스 코드에 대해서 최대한 자세히 설명해주세요!  코드를 한 줄씩 설명해보세요. (코드의 각 키워드가 무슨 의미인지 한 번 되돌아봅시다.)  이 메서드의 작동 원리에 대해서 설명해주세요.  필요한 경우가 어떤 경우가 있을지 고민하여 하나의 예를 들어주세요.  :point_right: reference code_.shuffle = function (arr) {  let arrCloned = arr.slice();  for (let fromIdx = 0; fromIdx &lt; arr.length; fromIdx++) {    const toIdx = Math.floor(Math.random() * arr.length);    let temp = arrCloned[fromIdx];    arrCloned[fromIdx] = arrCloned[toIdx];    arrCloned[toIdx] = temp;  }  return arrCloned;};shuffle 메서드는 배열 요소의 순서가 랜덤하게 변경된 새로운 배열을 리턴한다.다양한 상황 (ex. 비디오 또는 음악 재생의 순서를 섞을 때) 에서 유용하게 쓰일 수 있다.그러면 본격적으로 코드를 설명하기위해 한 줄씩 파헤쳐보자 !  :point_right: codelet arrCloned = arr.slice();arrCloned 이라는 변수에 얕은 복사를 통하여 배열을 가져왔다. 여기서 중요한 점은 slice() 는 원본을 대체하지 않는 점, 즉 원본은 따로 있다는 뜻이다.String 및 Number 객체 가 아닌 경우 문자열과 숫자는 새 배열에 복사한다. 이 새 배열에서는 마음대로 값을 바꿔도 원본에 아무런 영향을 주지 않는 다는 점을 명심하자. for (let fromIdx = 0; fromIdx &lt; arr.length; fromIdx++) {주어진 배열의 요소를 확인하기 위해 for loop 를 사용하였다. 일반적인 배열 반복문이다.const toIdx = Math.floor(Math.random() * arr.length);이부분에서 특히 random() 메서드가 생소해서 많이 찾아봤던 것 같다. 먼저 ranmdom() 메서드는 0이상 1 미만의 부동소숫점 의사 난수를 반환 값으로 한다. 그렇기때문에 앞에 floor(반버림) 메서드를 사용하여 정수인 난수를 생성한다고 보면 될 것 같다. round(반올림) 메서드를 사용할 수 도 있지만, 이렇게 하면 난수가 고르게 분포하지 않게 된다.random() 메서드에 배열의 길이(arr.length)를 곱해준 이유는 배열의 길이에 가까운 임의의 정수를 생성하기 위함인 것 같다.let temp = arrCloned[fromIdx];얕은복사를 통해 가져온 배열의 요소를 temp라는 변수에 할당을 한다. 할당을 한 이유에 대해서는 밑에서 설명한다.다음 코드를 넘어가기 전에 배열 비구조화 할당 문법을 충분히 이해를 하고 가자. 이해를 돕기 위해 먼저 간단한 코드를 예시로 든다.const array = [1, 2];const [one, two] = array;console.log(one);  // 1console.log(two);  // 2이 문법은 배열 안에 있는 원소를 다른 이름으로 새로 선언해주고 싶을 때 사용하면 매우 유용하다.arrCloned[fromIdx] = arrCloned[toIdx];arrCloned[toIdx] = temp;이 코드를 설명하기 위해 먼저 arrCloned = [1, ‘a’, 2, ‘b’] 라는 배열이라고 가정하자. 반복문을 통해 첫번째 i 는 arrCloned[0] 가 될 것이고 값은 1 이다. toIdx는 random() 메서드를 통해 임의로 3의 정수가 나왔다고 가정하자.위에 코드는 arrCloned[0] = arrCloned[3];arrCloned[3] = temp (arrCloned[fromIdx] 변수를 할당한 이유);이렇게 반복문을 한 번 돌고 나면 배열은 [‘b’, ‘a’, 2, 1] 이라는 값으로 임의로 변하게 된다. 이런 식으로 반복문을 다 돌고나면 랜덤하게 변경된 새로운 배열 값이 나올 것 이다.이 부분이 shuffle 메서드의 핵심인 것 같다.return arrCloned;그리고 반복문을 다돌고 새로 배열된 배열 값을 리턴(반환) 해준다.이 공부를 통해 shuffle 메서드를 완벽히 짚고 넘어갈 수 있게 되었다. 얕은 복사를 통해 랜덤하게 배열을 섞을 때 사용하면 유용한 메서드라고 생각한다. 앞서 설명했듯이 음악 재생을 랜덤으로 돌릴 때나 무작위로 섞고 싶을 때 사용하면 유용할 것 같다.2. 객체 21번  객체 문제 :문자열을 입력받아 가장 많이 반복되는 문자를 리턴해야 합니다.  주의사항 :          띄어쓰기는 제외      가장 많이 반복되는 문자가 다수일 경우, 먼저 도달한 문자를 리턴      빈 문자열을 입력받은 경우, 빈 문자열을 리턴        입출력 예시let output = mostFrequentCharacter('apples not oranges');console.log(output); // --&gt; 'p'output = mostFrequentCharacter('hello world');console.log(output); // --&gt; 'l'  pseudocode(수도코드)          문자열을 반복문으로 순회를 하면서 어떤 문자가 가장 많이 반복되는지 카운트를 세어주어야 한다.      리턴되는 값은 문자열이기 때문에 문자열도 같이 할당한다.      반복문으로 문자열을 순회하면서, 띄어쓰기는 건너뛰고 객체에 key 값과 value값을 할당한다.      반복문으로 문자열을 순회하면서, 반복되는 문자열을 카운트해준다.      가장 많이 카운트 된 문자를 가져온다.      비구조화 할당을 통해 가장 많이 반복된 문자를 할당한다.      할당된 객체를 리턴한다.      let obj = {max: 0, countStr: ''};    for (let i = 0; i &lt; str.length; i++) {     if (str[i] === ' ') {       continue;     }     if (obj[str[i]] === undefined) {       obj[str[i]] = 0;     }     obj[str[i]]++;   if (obj['max'] &lt; obj[str[i]]) {     obj['max'] = obj[str[i]];     obj['countStr'] = str[i];   }  }   return obj['countStr'];이 문제의 핵심은 먼저 카운트를 할 객체를 할당하고, 카운트가 된 값을 비구조화 할당으로 가져오는 것이다. 나는 이 문제를 풀 때 처음에는 max = str[0] 로 할당하고 max 값의 문자를 반환하려고 했다. 오랜 삽질 끝에  let obj = {};  let max = str[0];   if(str === '') {        return '';  }  for(let i = 0; i &lt; str.length; i++) {    if(str[i] === ' ') {                            continue;                                }                                        else if(obj[str[i]] === undefined) {            obj[str[i]] = 0;    }    obj[str[i]]++;        if(obj[max] &lt; obj[str[i]]) {             obj[str[i]];                   max = str[i];          }  }       if( Object.keys(obj).length === 0 ) {     return '';   }       return max;      이 코드로 문제를 풀어보기도 했다. 하지만 이 삽질이 결국 HA 시험에 큰 도움이 되었다. HA 시험 1번 문제를 가볍게 풀 수 있었다.3. 고차함수 31번  고차함수 문제 :아래 조건에 맞게 변형된 배열을 리턴해야 합니다.  주의사항 :          반복문 사용 금지      배열을 리턴      학생들의 성적을 평균값으로 변형해야 합니다.        입출력 예시let studentList = [  {    name: 'Anna',    gender: 'female',    grades: [4.5, 3.5, 4],  },  {    name: 'Dennis',    gender: 'male',    country: 'Germany',    grades: [5, 1.5, 4],  },  {    name: 'Martha',    gender: 'female',    grades: [5, 4, 4, 3],  },];console.log(output); // --&gt;[  { name: 'Anna', gender: 'female', grades: 4 },  { name: 'Martha', gender: 'female', grades: 4 },];  pseudocode(수도코드)          먼저 value 값이 ‘female’ 인 것만 필터링을 한다.      변형된 값을 반환하기 위해 맵핑을 하며 리턴을 한다.      평균 값을 구하기 위해 reduce 함수를 사용한다.      구한 평균값을 객체에 할당해준다.      객체를 리턴(반환)한다.        const filtering = students.filter (el =&gt; el.gender === 'female');  return filtering.map (function (el) {    const average = el.grades.reduce (function (acc, cur) {      return acc + cur;    }, 0);    const grade = average / el.grades.length;    el.grades = grade;        return el;  });각 함수의 뜻을 정확히 이해하면 쉽게 풀 수 있는 문제였다. 함수를 하나씩 차근 차근 써가면서 내려가보니 답을 찾을 수 있었다.하지만 이 문제 또한 삽질을 안 한건 아니다. 매개변수 el 값을 계속 가져오면서 마지막에 평균 값을 할당하는 것이 막혔었다. 원리를 하나씩 짚어보며 풀어가다보니 해결할 수 있었다.  :punch: 내일의 TIW(today I Will)재귀함수, 알고리즘">
    <meta itemprop="datePublished" content="2021-01-12T00:00:00+09:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">TIL #3
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          4 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title">
<i class="fas fa-file-alt"></i> 페이지 주요 목차</h4></header>
              <ul class="toc__menu">
<li><a href="#1-shuffle-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%84%A4%EB%AA%85">1. shuffle 메서드 설명</a></li>
<li><a href="#2-%EA%B0%9D%EC%B2%B4-21%EB%B2%88">2. 객체 21번</a></li>
<li><a href="#3-%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98-31%EB%B2%88">3. 고차함수 31번</a></li>
</ul>

            </nav>
          </aside>
        
        <h2 id="1-shuffle-메서드-설명">1. shuffle 메서드 설명</h2>

<blockquote>
  <p>shuffle 레퍼런스 설명 :</p>
</blockquote>

<p>아래 shuffle 레퍼런스 코드에 대해서 <strong>최대한 자세히 설명해주세요!</strong></p>

<ul>
  <li>코드를 한 줄씩 설명해보세요. (코드의 각 키워드가 무슨 의미인지 한 번 되돌아봅시다.)</li>
  <li>이 메서드의 작동 원리에 대해서 설명해주세요.</li>
  <li>필요한 경우가 어떤 경우가 있을지 고민하여 하나의 예를 들어주세요.</li>
</ul>

<blockquote>
  <p><img class="emoji" title=":point_right:" alt=":point_right:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png" height="20" width="20"> <strong>reference code</strong></p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">_</span><span class="p">.</span><span class="nx">shuffle</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">arrCloned</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">fromIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">fromIdx</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">fromIdx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">toIdx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arrCloned</span><span class="p">[</span><span class="nx">fromIdx</span><span class="p">];</span>
    <span class="nx">arrCloned</span><span class="p">[</span><span class="nx">fromIdx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arrCloned</span><span class="p">[</span><span class="nx">toIdx</span><span class="p">];</span>
    <span class="nx">arrCloned</span><span class="p">[</span><span class="nx">toIdx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">arrCloned</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>shuffle 메서드는 배열 요소의 순서가 랜덤하게 변경된 새로운 배열을 리턴한다.</p>

<p>다양한 상황 (ex. 비디오 또는 음악 재생의 순서를 섞을 때) 에서 유용하게 쓰일 수 있다.</p>

<p>그러면 본격적으로 코드를 설명하기위해 한 줄씩 파헤쳐보자 !</p>

<blockquote>
  <p><img class="emoji" title=":point_right:" alt=":point_right:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png" height="20" width="20"> <strong>code</strong></p>
</blockquote>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arrCloned</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
</code></pre></div></div>
<p>arrCloned 이라는 변수에 얕은 복사를 통하여 배열을 가져왔다. 여기서 중요한 점은 slice() 는 원본을 대체하지 않는 점, 즉 원본은 따로 있다는 뜻이다.</p>

<p><u>String 및 Number 객체</u> 가 아닌 경우 문자열과 숫자는 새 배열에 복사한다. 이 새 배열에서는 마음대로 값을 바꿔도 원본에 아무런 영향을 주지 않는 다는 점을 명심하자.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">fromIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">fromIdx</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">fromIdx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</code></pre></div></div>

<p>주어진 배열의 요소를 확인하기 위해 for loop 를 사용하였다. 일반적인 배열 반복문이다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">toIdx</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
</code></pre></div></div>

<p>이부분에서 특히 random() 메서드가 생소해서 많이 찾아봤던 것 같다. 먼저 ranmdom() 메서드는 <u>0이상 1 미만의 부동소숫점 의사 난수</u>를 반환 값으로 한다.<br> 그렇기때문에 앞에 floor(반버림) 메서드를 사용하여 정수인 난수를 생성한다고 보면 될 것 같다. round(반올림) 메서드를 사용할 수 도 있지만, 이렇게 하면 난수가 고르게 분포하지 않게 된다.</p>

<p>random() 메서드에 배열의 길이(arr.length)를 곱해준 이유는 배열의 길이에 가까운 임의의 정수를 생성하기 위함인 것 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">arrCloned</span><span class="p">[</span><span class="nx">fromIdx</span><span class="p">];</span>
</code></pre></div></div>

<p>얕은복사를 통해 가져온 배열의 요소를 temp라는 변수에 할당을 한다. 할당을 한 이유에 대해서는 밑에서 설명한다.</p>

<p>다음 코드를 넘어가기 전에 <strong>배열 비구조화 할당</strong> 문법을 충분히 이해를 하고 가자. 이해를 돕기 위해 먼저 간단한 코드를 예시로 든다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">one</span><span class="p">,</span> <span class="nx">two</span><span class="p">]</span> <span class="o">=</span> <span class="nx">array</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">one</span><span class="p">);</span>  <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">two</span><span class="p">);</span>  <span class="c1">// 2</span>
</code></pre></div></div>
<p>이 문법은 배열 안에 있는 원소를 다른 이름으로 새로 선언해주고 싶을 때 사용하면 매우 유용하다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">arrCloned</span><span class="p">[</span><span class="nx">fromIdx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arrCloned</span><span class="p">[</span><span class="nx">toIdx</span><span class="p">];</span>
<span class="nx">arrCloned</span><span class="p">[</span><span class="nx">toIdx</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
</code></pre></div></div>

<p>이 코드를 설명하기 위해 먼저 <strong>arrCloned = [1, ‘a’, 2, ‘b’]</strong> 라는 배열이라고 가정하자.<br> 반복문을 통해 첫번째 i 는 arrCloned[0] 가 될 것이고 값은 1 이다. toIdx는 random() 메서드를 통해 임의로 3의 정수가 나왔다고 가정하자.<br>
위에 코드는<br> 
arrCloned[0] = arrCloned[3];<br>
arrCloned[3] = temp (arrCloned[fromIdx] 변수를 할당한 이유);<br>
이렇게 반복문을 한 번 돌고 나면 배열은 [‘b’, ‘a’, 2, 1] 이라는 값으로 임의로 변하게 된다. 이런 식으로 반복문을 다 돌고나면 랜덤하게 변경된 새로운 배열 값이 나올 것 이다.<br>이 부분이 <u>shuffle 메서드의 핵심</u>인 것 같다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">return</span> <span class="nx">arrCloned</span><span class="p">;</span>
</code></pre></div></div>
<p>그리고 반복문을 다돌고 새로 배열된 배열 값을 리턴(반환) 해준다.</p>

<p>이 공부를 통해 shuffle 메서드를 완벽히 짚고 넘어갈 수 있게 되었다. 얕은 복사를 통해 랜덤하게 배열을 섞을 때 사용하면 유용한 메서드라고 생각한다. 앞서 설명했듯이 음악 재생을 랜덤으로 돌릴 때나 무작위로 섞고 싶을 때 사용하면 유용할 것 같다.</p>

<p><br>
<br>
<br></p>

<h2 id="2-객체-21번">2. 객체 21번</h2>

<blockquote>
  <p>객체 문제 :</p>
</blockquote>

<p>문자열을 입력받아 가장 많이 반복되는 문자를 리턴해야 합니다.</p>

<ul>
  <li>주의사항 :
    <ol>
      <li>띄어쓰기는 제외</li>
      <li>가장 많이 반복되는 문자가 다수일 경우, 먼저 도달한 문자를 리턴</li>
      <li>빈 문자열을 입력받은 경우, 빈 문자열을 리턴</li>
    </ol>
  </li>
  <li>입출력 예시</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">output</span> <span class="o">=</span> <span class="nx">mostFrequentCharacter</span><span class="p">(</span><span class="dl">'</span><span class="s1">apples not oranges</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 'p'</span>

<span class="nx">output</span> <span class="o">=</span> <span class="nx">mostFrequentCharacter</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt; 'l'</span>
</code></pre></div></div>

<ul>
  <li>pseudocode(수도코드)
    <ol>
      <li>문자열을 반복문으로 순회를 하면서 어떤 문자가 가장 많이 반복되는지 카운트를 세어주어야 한다.</li>
      <li>리턴되는 값은 문자열이기 때문에 문자열도 같이 할당한다.</li>
      <li>반복문으로 문자열을 순회하면서, 띄어쓰기는 건너뛰고 객체에 key 값과 value값을 할당한다.</li>
      <li>반복문으로 문자열을 순회하면서, 반복되는 문자열을 카운트해준다.</li>
      <li>가장 많이 카운트 된 문자를 가져온다.</li>
      <li>비구조화 할당을 통해 가장 많이 반복된 문자를 할당한다.</li>
      <li>할당된 객체를 리턴한다.</li>
    </ol>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">max</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">countStr</span><span class="p">:</span> <span class="dl">''</span><span class="p">};</span> 
   <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">continue</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="dl">'</span><span class="s1">max</span><span class="dl">'</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span> <span class="p">{</span>
     <span class="nx">obj</span><span class="p">[</span><span class="dl">'</span><span class="s1">max</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>
     <span class="nx">obj</span><span class="p">[</span><span class="dl">'</span><span class="s1">countStr</span><span class="dl">'</span><span class="p">]</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
   <span class="p">}</span>
  <span class="p">}</span>
   <span class="k">return</span> <span class="nx">obj</span><span class="p">[</span><span class="dl">'</span><span class="s1">countStr</span><span class="dl">'</span><span class="p">];</span>
</code></pre></div></div>

<p>이 문제의 핵심은 먼저 카운트를 할 객체를 할당하고, 카운트가 된 값을 비구조화 할당으로 가져오는 것이다.<br> 나는 이 문제를 풀 때 처음에는 max = str[0] 로 할당하고 max 값의 문자를 반환하려고 했다. 오랜 삽질 끝에</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">let</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> 
  <span class="k">if</span><span class="p">(</span><span class="nx">str</span> <span class="o">===</span> <span class="dl">''</span><span class="p">)</span> <span class="p">{</span>    
    <span class="k">return</span> <span class="dl">''</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>                    
        <span class="k">continue</span><span class="p">;</span>                            
    <span class="p">}</span>                                    
    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>      
      <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>  
      <span class="k">if</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">max</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]])</span> <span class="p">{</span>   
          <span class="nx">obj</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]];</span>         
          <span class="nx">max</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>    
      <span class="p">}</span>
  <span class="p">}</span>    
   <span class="k">if</span><span class="p">(</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">).</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
     <span class="k">return</span> <span class="dl">''</span><span class="p">;</span>
   <span class="p">}</span>
       <span class="k">return</span> <span class="nx">max</span><span class="p">;</span>      
</code></pre></div></div>

<p>이 코드로 문제를 풀어보기도 했다. 하지만 이 삽질이 결국 HA 시험에 큰 도움이 되었다. HA 시험 1번 문제를 가볍게 풀 수 있었다.</p>

<p><br>
<br>
<br></p>

<h2 id="3-고차함수-31번">3. 고차함수 31번</h2>
<blockquote>
  <p>고차함수 문제 :</p>
</blockquote>

<p>아래 조건에 맞게 변형된 배열을 리턴해야 합니다.</p>

<ul>
  <li>주의사항 :
    <ol>
      <li>반복문 사용 금지</li>
      <li>배열을 리턴</li>
      <li>학생들의 성적을 평균값으로 변형해야 합니다.</li>
    </ol>
  </li>
  <li>입출력 예시</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">studentList</span> <span class="o">=</span> <span class="p">[</span>
  <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Anna</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">gender</span><span class="p">:</span> <span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">grades</span><span class="p">:</span> <span class="p">[</span><span class="mf">4.5</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Dennis</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">gender</span><span class="p">:</span> <span class="dl">'</span><span class="s1">male</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">country</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Germany</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">grades</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
  <span class="p">},</span>
  <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Martha</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">gender</span><span class="p">:</span> <span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">grades</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
  <span class="p">},</span>
<span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">output</span><span class="p">);</span> <span class="c1">// --&gt;</span>
<span class="p">[</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Anna</span><span class="dl">'</span><span class="p">,</span> <span class="na">gender</span><span class="p">:</span> <span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">,</span> <span class="na">grades</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Martha</span><span class="dl">'</span><span class="p">,</span> <span class="na">gender</span><span class="p">:</span> <span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">,</span> <span class="na">grades</span><span class="p">:</span> <span class="mi">4</span> <span class="p">},</span>
<span class="p">];</span>
</code></pre></div></div>

<ul>
  <li>pseudocode(수도코드)
    <ol>
      <li>먼저 value 값이 ‘female’ 인 것만 필터링을 한다.</li>
      <li>변형된 값을 반환하기 위해 맵핑을 하며 리턴을 한다.</li>
      <li>평균 값을 구하기 위해 reduce 함수를 사용한다.</li>
      <li>구한 평균값을 객체에 할당해준다.</li>
      <li>객체를 리턴(반환)한다.</li>
    </ol>
  </li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">filtering</span> <span class="o">=</span> <span class="nx">students</span><span class="p">.</span><span class="nx">filter</span> <span class="p">(</span><span class="nx">el</span> <span class="o">=&gt;</span> <span class="nx">el</span><span class="p">.</span><span class="nx">gender</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">female</span><span class="dl">'</span><span class="p">);</span>

  <span class="k">return</span> <span class="nx">filtering</span><span class="p">.</span><span class="nx">map</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">el</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">average</span> <span class="o">=</span> <span class="nx">el</span><span class="p">.</span><span class="nx">grades</span><span class="p">.</span><span class="nx">reduce</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">cur</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">acc</span> <span class="o">+</span> <span class="nx">cur</span><span class="p">;</span>
    <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">grade</span> <span class="o">=</span> <span class="nx">average</span> <span class="o">/</span> <span class="nx">el</span><span class="p">.</span><span class="nx">grades</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
    <span class="nx">el</span><span class="p">.</span><span class="nx">grades</span> <span class="o">=</span> <span class="nx">grade</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nx">el</span><span class="p">;</span>
  <span class="p">});</span>
</code></pre></div></div>

<p>각 함수의 뜻을 정확히 이해하면 쉽게 풀 수 있는 문제였다. 함수를 하나씩 차근 차근 써가면서 내려가보니 답을 찾을 수 있었다.<br>하지만 이 문제 또한 삽질을 안 한건 아니다. 매개변수 el 값을 계속 가져오면서 마지막에 평균 값을 할당하는 것이 막혔었다.<br> 원리를 하나씩 짚어보며 풀어가다보니 해결할 수 있었다.</p>

<blockquote>
  <p><img class="emoji" title=":punch:" alt=":punch:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png" height="20" width="20"> <strong>내일의 TIW(today I Will)</strong></p>
</blockquote>

<p>재귀함수, 알고리즘</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#pre-course" class="page__taxonomy-item" rel="tag">Pre-Course</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#2021-01" class="page__taxonomy-item" rel="tag">2021/01</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-01-12T00:00:00+09:00">January 12, 2021</time></p>


      </footer>

      <section class="page__share">
  

  <a href="https://twitter.com/intent/tweet?text=TIL+%233%20http%3A%2F%2Flocalhost%3A4000%2F2021%2F01%2FTIL3%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2021%2F01%2FTIL3%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3A%2F%2Flocalhost%3A4000%2F2021%2F01%2FTIL3%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/2021/01/TIL2/" class="pagination--pager" title="TIL #2
">Previous</a>
    
    
      <a href="/2021/01/TIL4/" class="pagination--pager" title="TIL #4
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You May Also Enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/2021/01/TIL14/" rel="permalink">TIL #14
</a>
      
    </h2>

    
		<p class="archive__item-excerpt"><i class="far fa-folder-open"></i> Pre-Course</p>
	
<!-- 카테고리만 보여주는 코드 -->

    <p class="archive__item-excerpt"><i class="far fa-calendar-alt"></i> 01/23/2021 </p>
<!-- 날짜만 보여주는 코드 -->
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">


반복문은 정말 셀 수 없을 정도로 복습을 많이 한 것 같다.

아는 내용도 또 풀고, 모르는 내용은 그거에 몇 십번은 더 풀어보고 할 정도였다...

오늘은 이번주 중에서 반복문이 핵심내용이였기 때문에 한 번 더 복습하려고 한다. 내 TIL에서 마지막 반복문 블로깅이 될 것 ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/2021/01/TIL13/" rel="permalink">TIL #13
</a>
      
    </h2>

    
		<p class="archive__item-excerpt"><i class="far fa-folder-open"></i> Pre-CourseHTML&amp;CSS</p>
	
<!-- 카테고리만 보여주는 코드 -->

    <p class="archive__item-excerpt"><i class="far fa-calendar-alt"></i> 01/22/2021 </p>
<!-- 날짜만 보여주는 코드 -->
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">계산기 이쁘게 구현하기

오늘은 계산기에 대해 기본적인 구현방법에 대해서 배워보고 직접 해보는 시간을 가졌다. 어느정도 할 줄을 알았기에 나는 빠르게 구현을 끝내고 CSS에 집중을 했다.


많은 동기들이 계산기를 구현하느라 JS파일에만 집중을해서 대부분 동기들이 CSS부분은 건드...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/2021/01/TIL12/" rel="permalink">TIL #12
</a>
      
    </h2>

    
		<p class="archive__item-excerpt"><i class="far fa-folder-open"></i> Pre-CourseHTML&amp;CSS</p>
	
<!-- 카테고리만 보여주는 코드 -->

    <p class="archive__item-excerpt"><i class="far fa-calendar-alt"></i> 01/21/2021 </p>
<!-- 날짜만 보여주는 코드 -->
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">1. html 배운 내용 정리


  <img class="emoji" title=":point_right:" alt=":point_right:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png" height="20" width="20"> html 기초 :






외우자! <img class="emoji" title=":facepunch:" alt=":facepunch:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png" height="20" width="20"> HTML = 구조 CSS = 스타일 JS = 상호작용

먼저, HTML은 구조를 만든다!

즉, 공사를 하기전에 틀을 만들어 주는 것 인데, 이 틀을 대충 만들...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/2021/01/TIL11/" rel="permalink">TIL #11
</a>
      
    </h2>

    
		<p class="archive__item-excerpt"><i class="far fa-folder-open"></i> Pre-Course</p>
	
<!-- 카테고리만 보여주는 코드 -->

    <p class="archive__item-excerpt"><i class="far fa-calendar-alt"></i> 01/20/2021 </p>
<!-- 날짜만 보여주는 코드 -->
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          less than 1 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">1. 반복문 for while

  <img class="emoji" title=":point_right:" alt=":point_right:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png" height="20" width="20"> for, while :



1-1 for loop 문법

반복문은 반복할 조건을 초기화, 조건식, 증감문 순으로 넣어준다.


  초기화 : 시작부분이라고도 표현할 수 있다. i = 0 // 0부터 시작하겠다.
  조건...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap">
<form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term...">
  </form>
  <div id="results" class="results"></div>
</div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    
      
        
          <li><a href="https://github.com/useonglee" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="mailto:useong0830@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i> Email</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">© 2021 꿈을 기록하는 Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
