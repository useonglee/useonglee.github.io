---
layout: post
title: "JS 복습 및 면접 질문 정리 1차"
subtitle: "📅 TIL #133"
toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
date: 2021-06-22
background: "/img/posts/post-TIL.png"
tags: [TIL, js, frontend]
---

<br/>
<br/>
<br/>

# 🎯 Achievement Goals

> 1.  event delegation에 관해 설명해주세요.<br />
> 2.  이벤트 버블링(Event Bubbling)에 대해서 설명하세요.<br />
> 3.  이벤트 캡쳐링(Event Capturing)에 대해서 설명하세요.<br />
> 4.  this는 JavaScript에서 어떻게 작동하는지 설명해주세요.<br />
> 5.  null과 unedefined 그리고 undeclared의 차이점은 무엇인가요?<br />
> 6.  클로져(Closure)는 무엇이며, 어떻게/왜 사용하는지 설명해주세요.<br />
> 7.  AJAX에 관해 가능한 한 자세히 설명하세요.<br />
> 8.  AJAX를 사용했을 때의 장단점에 대해 설명해주세요.<br />
> 9.  let, var, const의 차이점에 관해서 설명해주세요.<br />
> 10. JavaScript의 작동방식의 장단점에 관해 설명해주세요.<br />
> 11. new 연산자의 차이점은 무엇인가요?<br />
> 12. SPA에서 SEO에 유리하도록 만들기 위한 방법에 대해 설명해주세요.<br />

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

## 1. event delegation에 관해 설명해주세요.

<br />
이벤트 위임은 이벤트 캡처링과 버블링을 활용한 이벤트 핸들링 패턴입니다. 이벤트 위임을 사용하면 요소마다 핸들러를 할당하지 않고, 요소의 공통 부모에 이벤트 핸들러를 단 하나만 할당하여 여러 요소를 한꺼번에 다룰 수 있습니다.

<br />
이벤트 위임을 이용하면 요소마다 핸들러를 할당하지 않아도 되기 때문에 메모리가 절약되고, 코드가 간결해지는 장점이 있습니다.

<br />
이벤트 위임의 단점은 이벤트가 반드시 버블링 되어야 한다는 것입니다. 그리고 낮은 레벨에 할당한 핸드러에는 `event.stopPropagation()`를 사용할 수 없습니다.

<br />
이벤트 위임의 원리는 이렇습니다.

1. 부모 요소에 하나의 핸들러를 할당해줍니다.
2. 핸들러의 `event.target`을 사용해 어느 요소에서 이벤트가 발생한 것인지 찾아냅니다.
3. 이벤트가 발생한 요소가 원하는 요소일 때 이벤트를 실행시킵니다.

<br />
<br />

## 2. 이벤트 버블링(Event Bubbling)에 대해서 설명하세요.

<br />

<img width="457" alt="event-bubble" src="https://user-images.githubusercontent.com/75570915/122947979-83e07a00-d3b5-11eb-916a-b6d38474a195.png">{: width="100%" height="100%"}

<br/>
**이벤트 버블링**은 특정 화면 요소에서 이벤트가 발생했을 때 해당 **이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성**을 의미합니다.

<br />
버블링의 원리는 이렇습니다.

1. 요소에 이벤트가 발생합니다.
2. 해당 요소의 핸들러가 동작합니다.
3. 이어서 부모 요소의 핸들러 동작합니다.
4. document 객체를 만날 때까지, 각 요소에 할당된 onclick 핸들러가 동작합니다.

<br />
<br />

## 3. 이벤트 캡쳐링(Event Capturing)에 대해서 설명하세요.

<br />

<img width="459" alt="event-capture" src="https://user-images.githubusercontent.com/75570915/122947990-8511a700-d3b5-11eb-9c31-1e68c14aa0ef.png">{: width="100%" height="100%"}

<br/>
이벤트 캡쳐링은 버블링과 반대 방향으로 전파되는 특징을 가지고 있습니다. 이벤트 캡쳐링을 이용할 땐 이벤트 리스너에 한가지 옵션을 추가해주어야 합니다. addEventListener(event, handler, capture) 세번째 인자에 boolean 값을 넣어주어 버블링 단계에서 동작할지 캡쳐링 단계에서 동작할지 정할 수 있습니다.

<br />
<br />

## 4. this는 JavaScript에서 어떻게 작동하는지 설명해주세요.

<br />
this는 작성 시점이 아닌 런타임 시점에 바인딩 되며 함수 호출 당시 상황에 따라 컨텍스트가 결정됩니다. 함수 선언 위치와 상관없이 this 바인딩은 오로지 어떻게 함수를 호출했느냐에 따라 정해집니다.

<br />
함수가 객체의 프로퍼티라면 메소드로서 호출이 됩니다. 메소드 내부의 this는 메소드를 소유한 객체에 바인딩됩니다. 즉, 메소드를 호출한 객체에 바인딩이 됩니다.

```js
const person = {
  name: "useonglee",
  greet: function () {
    console.log("Hi, My name is " + this.name);
  },
};

const otherPerson = {
  name: "kim",
};

otherPerson.greet = person.greet;

person.greet(); //Hi, my name is useonglee
otherPerson.greet(); //Hi, my name is kim
```

<br />
전역 스코프를 갖는 전역 객체는 전역 변수를 프로퍼티로 가지고 있습니다. 전역 스코프에 선언된 함수는 전역 객체의 메소드인 셈입니다. 즉, 전역 스코프에서 호출된 함수 내부의 `this`는 기본적으로 전역 객체에 바인딩 됩니다.

<br />

```js
function greet() {
  console.log(this);
}

greet(); //window
```

<br />
자바스크립트 엔진에 의해 함수 호출 방법에 따른 this가 동적으로 할당을 합니다. 하지만, apply, call, bind를 사용하면 명시적으로 this를 바인딩할 수 있습니다.

<br/>
어떤 함수를 호출하면 실행 컨텍스트가 만들어지는데, 여기에는 함수가 호출된 근원, 호출 방법, 전달된 인자 등의 정보가 담겨있습니다. this 레퍼런스는 그 중 하나로, 함수가 실행되는 동안 이용할 수 있습니다.

<br />
(함수를 어떻게 호출했는지 상관하지 않고 this 값을 설정할 수 있는 것이 bind 메서드)

<br />
<br />

## 5. null과 unedefined 그리고 undeclared의 차이점은 무엇인가요?

<br />
null과 undefined 둘 다 값이 없다라는 것을 나타낼 때 사용합니다.

<br />
null 변수는 명시적으로 null이 할당된 경우 생깁니다. null은 아무런 값도 나타내지 않습니다만 무언가 할당은 된 것이기 때문에 undefined와 다릅니다. null을 체크하기 위해서는 간단하게 === 연산자를 사용하면 됩니다. null에 typeof를 하면 undefined에서는 'undefined'가 나왔던 것과 다르게 `object`가 나오게 되니 유의해야 합니다.

<br />
정의되지 않은 상태는 변수를 선언한 뒤에 아무것도 할당하지 않은 상태를 말합니다. 만일 아무런 값도 반환하지 않는 함수를 특정 변수에 할당하면, 변수는 undefined 상태를 갖게 됩니다. 이러한 상태를 체크하기 위해 엄격한 동등 비교 (===) 연산자나 typeof 키워드를 사용하여 `undefined` 문자열을 받아낼 수 있습니다. 엄격하지 않은 동등 비교 (==)는 null 값과 undefined를 비교했을 때도 true를 반환하므로 부정확합니다.

<br />
undeclared의 경우 `use strict` 명령어를 통해 엄격모드 로 진입하지 않으면, 만나기 힘듭니다.

<br />
엄격모드가 아닌 자바스크립트에서 선언되지 않은 변수에 값을 할당하면 자동으로 global 변수로 취급되기 때문입니다.

<br />
`??` 나 `||`연산자로 null이나 undefined를 체크할 수 있습니다.

<br />
<br />

## 6. 클로져(Closure)는 무엇이며, 어떻게/왜 사용하는지 설명해주세요.

<br />
클로져는 반환된 내부 함수가 자신이 선언 됐을 때의 환경 즉, 렉시컬 스코핑 하여 선언 됐을 때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수를 말합니다.

실행 컨텍스트 관점에서 설명을 드리면, 내부 함수가 유효한 상태에서 외부 함수가 종료하여 외부 함수의 실행 컨텍스트가 반환되어도, 그 외부 함수 실행 컨텍스트 내의 활성 객체는 내부 함수에 의해 참조되는한 유효하기 때문에, 내부 함수가 스코프 체인을 통해 참조할 수 있는 것을 의미합니다.

사용하는 이유는 전역 변수를 대체하여 클로저를 사용할 수 있고, 전역 변수의 남용을 막을 수 있고 변수 값을 은닉하는 용도로도 사용합니다.

<br />
<br />

## 7. AJAX에 관해 가능한 한 자세히 설명하세요.

<br />
AJAX란, JavaScript의 라이브러리중 하나이며 Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자이다. 브라우저가 가지고있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로드하는 기법 이며 **JavaScript를 사용한 비동기 통신, 클라이언트와 서버간에 XML 데이터를 주고받는 기술**이다.

즉, 쉽게 말하자면 **자바스크립트를 통해서 서버에 데이터를 요청하는 것**이다.

##### AJAX의 진행과정

1. XMLHttpRequest Object를 만든다.
   - request를 보낼 준비를 브라우저에게 시키는 과정
   - 이것을 위해서 필요한 method를 갖춘 object가 필요함
2. callback 함수를 만든다.
   - 서버에서 response가 왔을 때 실행시키는 함수
   - HTML 페이지를 업데이트 함
3. Open a request
   - 서버에서 response가 왔을 때 실행시키는 함수
   - HTML 페이지를 업데이트 함
4. send the request

##### AJAX가 쓰이는 방법

XMLHttpRequest 객체를 얻은 뒤, url을 통해 요청하고 응답을 받으면 응답 결과에 맞는 함수를 실행하는 구조로 되어 있다. Ajax가 효율적이라고는 해도 이렇게 하게 될 경우, 코드가 길어지기 때문에 jQuery에서 그 문제를 해결해주고 있다.

<br />
<br />

## 8. AJAX를 사용했을 때의 장단점에 대해 설명해주세요.

<br />

##### 1. AJAX의 장점

- 웹페이지의 속도향상
- 서버의 처리가 완료될 때까지 기다리지 않고 처리가 가능하다.
- 서버에서 Data만 전송하면 되므로 전체적인 코딩의 양이 줄어든다.
- 기존 웹에서는 불가능했던 다양한 UI를 가능하게 해준다. ( Flickr의 경우, 사진의 제목이나 태그를 페이지의 리로드 없이 수정할 수 있다.)

##### 2. AJAX의 단점

- 히스토리 관리가 되지 않는다.
- 페이지 이동없는 통신으로 인한 보안상의 문제가 있다.
- 연속으로 데이터를 요청하면 서버 부하가 증가할 수 있다.
- XMLHttpRequest를 통해 통신하는 경우, 사용자에게 아무런 진행 정보가 주어지지 않는다. (요청이 완료되지 않았는데 사용자가 페이지를 떠나거나 오작동할 우려가 발생하게 된다.)
- AJAX를 쓸 수 없는 브라우저에 대한 문제 이슈가 있다.
- HTTP 클라이언트의 기능이 한정되어 있다.
- 지원하는 Charset이 한정되어 있다.
- Script로 작성되므로 디버깅이 용이하지 않다.
- 동일-출처 정책으로 인하여 다른 도메인과는 통신이 불가능하다. (Cross-Domain문제)

<br />
<br />

## 9. 호이스팅에 대해 설명하세요.

<br />
호이스팅은 코드에서 변수 선언의 동작을 설명하는데 사용되는 용어입니다. var 키워드로 선언되거나 초기화된 변수는 현재 스코프의 최상위까지 옮겨집니다. 이것을 호이스팅이라고 부릅니다. 그러나 선언문만 호이스팅되며 할당(있는 경우)은 그대로 있게 됩니다.

사실 선언은 실제로 이동되지 않습니다 - JavaScript 엔진은 컴파일 중에 선언을 파싱하고 선언과 해당 스코프를 인식합니다. 선언을 해당 스코프의 맨 위로 옮겨지는 것으로 생각하여 동작을 이해하는 것이 더 쉬울 뿐입니다.

<br />

함수 선언은 함수몸체가 호이스팅되는 반면, 변수 선언 형태로 작성된 함수 표현식은 변수 선언만 호이스팅됩니다.

<br />

```js
// 함수 선언
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
  console.log("FOOOOO");
}
console.log(foo); // [Function: foo]

// 함수 표현식
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
  console.log("BARRRR");
};
console.log(bar); // [Function: bar]
```

<br />
<br />

## 10. let, var, const의 차이점에 관해서 설명해주세요.

<br />
var는 함수 스코프, let const는 블록스코프로 크게 나뉩니다.

var는 변수 선언을 여러 번해도 에러없이 출력이 됩니다. 이러한 점은 변수명 남용 문제를 야기할 수 있으므로 큰 단점이라고 볼 수 있습니다. 그래서 ES6 문법이후로 let const가 추가되었습니다.

let, const 둘 다 변수 재선언 불가능하지만 변수의 immutable 여부에서 차이점이 있습니다.

let은 변수 재할당 가능, const는 변수 재선언 재할당 모두 불가능합니다.

<br />
var는 변수가 호이스트되도록 허용합니다. 즉, 변수가 선언되기 전에 코드에서 참조될 수 있습니다. let과 const는 이를 허용하지 않고 대신 에러를 던집니다.

<br />
<br />

## 11. new 연산자의 차이점은 무엇인가요.

<br />

```js
function Person() {}
var person = Person();
var person = new Person();

/*
첫번째는 함수 실행이 되면서 언디파인드를 반환합니다.
두번째는 new 연산자가 새로운 빈 객체를 메모리 상에 생성합니다.
생선된 빈 객체가 this 바인딩
*/
```

<br />
<br />

## 12. JavaScript의 작동방식의 장단점에 관해 설명해주세요.

<br />

##### 1. 속도 (Speed)

자바스크립트는 **인터프리터 언어**이기 때문에, 자바와 같이 컴파일이 필요한 다른 프로그래밍 언어에 비해 시간이 적게 소요된다. 또한 자바스크립트는 클라이언트 스크립트이기 때문에 서버 연결에 드는 시간을 절약할 수 있어서 프로그램 실행 속도를 높인다.

##### 2. 서버 로딩 (Server Load)

(클라이언트에서 동작하는 자바스크립트의 경우) 서버로 데이터를 주고 받지 않아도 브라우저 자체에서 데이터 유효성 검사를 할 수 있다. 만약 데이터가 불일치 하는 경우, 전체 페이지를 새로고침하지 않고, 브라우저가 페이지의 일부만 업데이트한다.

##### 3. 풍부한 인터페이스 (Rich Interfaces)

자바스크립트는 매력적인 웹 페이지를 만들기 위한 다양한 인터페이스를 제공한다. 드래그 앤 드롭이나 슬라이더는 웹 페이지에 풍부한 인터페이스를 제공한다. 이로 인해 웹 페이지에서의 사용자 상호작용(user interactivity)이 향상된다.

##### 4. 확장된 기능성 (Extended Functionality)

npm 등을 통해 라이브리러리를 추가할 수 있다. 이러한 풍부하고 잘 관리된 써드파티 라이브러리는 개발자로 하여금 빠르고 쉽게 자바스크립트 애플리케이션을 구축할 수 있도록 한다.

<br />
**단점**

##### 1. 클라이언트 보안 (Client-side Security)

자바스크립트 코드는 유저에게 보이기 때문에, 누군가가 악의적인 의도로 자바스크립트 코드를 사용할 수도 있다. 인증(authentification) 없이 소스 코드를 사용하는 것이 이에 해당한다. 또한 데이터 보안을 손상시킬 수 있는 악성 코드를 웹사이트에 삽입하는 것은 매우 쉽다.

##### 2. 브라우저 지원 (Browser Support)

브라우저마다 자바스크립트를 해석(interpret)하는 방법은 제각기 다르다. 따라서, 코드를 배포하기 전에 다양한 플랫폼에서 잘 돌아가는지 시험해봐야 한다. 또한 구형 브라우저는 새로운 기능을 지원하지 않는 경우가 있기 때문에 그 부분도 늘 확인해야 한다.

##### 3. 렌더링 중지 (Rendering Stopped)

코드에 에러가 딱 하나만 있어도 웹 사이트에서 동작하는 자바스크립트 코드가 완전히 렌더링을 중지해버린다. 사용자에게는 자바스크립트가 아예 없는 것처럼 보일 것이다. 그러나 브라우저는 이러한 에러에 매우 관대하다.

<br/>
<br/>
<br/>
<br/>

참고 자료

[이벤트 버블링과 캡쳐 이미지](https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84---event-delegation)<br/>

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
