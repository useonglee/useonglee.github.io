---
layout: post
title: "Greedy, DFS 알고리즘"
subtitle: "📅 TIL #42"
toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
date: 2021-03-08
background: "/img/posts/post-TIL.png"
tags: [TIL, immersive-course, Algorithm]
---

<br/>
<br/>

# <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">🎯 Achievement Goals</span>

<br/>
* 프로그래머스 Lv2. 구명보트
* 코플릿 [DFS] 바코드

<br/>
<br/>
<br/>

## 👉 프로그래머스 Lv2. 구명보트

<br/>

## 문제 설명

무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.

예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.

구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.

사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

## 제한사항

* 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.
* 각 사람의 몸무게는 40kg 이상 240kg 이하입니다.
* 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.
* 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.

## 입출력 예

|people|limit|return|
|:------:|:---:|:---:|
|[70, 50, 80, 50]|100|3|
|[70, 80, 50]|100|3|

<br/>
<br/>
<br/>

# 🤔 나의 생각

* 이 문제는 일단 <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">2명씩 밖에 탈 수 없다는 것</span>이 가장 포인트였다.
* 먼저 계산하기 쉽게 나는 정렬을 하고 시작했다.
* 그리고 제일 작은 숫자부터 나머지 하나의 값을 찾아서 `limit`를 넘지 않는 선에서 구출해준다는 생각을 했다.
* 가장 작은 숫자랑 나머지 숫자를 더해서 비교해 봤을 때 `limit` 를 모두 넘긴다면 그 숫자는 하나만 구출되게 했다.
* 가장 중요한 점은 작은 숫자를 가지고 나머지 하나를 어떻게 찾을 것인가 였다.
* 일단 가장 작은 인덱스 `0` 과 가장 큰 인덱스 `length-1`을 할당했다.
* 그리고 정렬을 했기때문에 가장 작은 숫자와 가장 큰 숫자를 더해서 `limit`보다 작은지 찾을 수 있다.
* 작은 숫자와 큰 숫자를 더했을 때, `limit` 보다 크다면 max 인덱스를 1 줄여주고 카운트를 했다.
* 만약 원하는 값이 나왔다면 min 인덱스 1을 더해 다음으로 작은 값에 대해서 찾았다.

<br/>
<br/>

> code
---

```js
function solution(people, limit) {
    people.sort((a, b) => a - b);
    
    let min = 0;
    let max = people.length-1;

    while(min <= max) {
        if (people[min] + people[max] <= limit) {
            min += 1;
        }
        max -= 1;
        count += 1;
    }
    return count;
}
```

<br/>
<br/>
<br/>

## 👉 코플릿 [DFS] 바코드

<br/>

> 문제
---

<br/>
1, 2, 3으로만 이루어진 수열 바코드를 만들어야 합니다. 무조건 1, 2, 3만 붙여서 바코드를 만들었다면 쉬웠겠지만, 아쉽게도 바코드를 만드는 데에 조건이 걸려 있습니다. 바코드에서 인접한 두 개의 부분 수열이 동일하다면 제작할 수 없다고 할 때, 주어진 길이 len의 바코드 중 가장 작은 수를 반환하는 함수를 작성하세요.

|만들 수 없는 바코드|만들 수 있는 바코드|
|:-----------------:|:---------------:|
|11|1312|
|1231312|3|
|232312|231213|

<br/>

> 출력
---

* `String` 타입을 리턴해야 합니다.
* 예시로, 121도, 123도 전부 바코드로 제작할 수 있지만 제일 작은 수는 121이기 때문에 121을 반환해야 합니다.

<br/>

> 입출력 예시
---

<br/>

```js

let output = barcode(3);
console.log(output); // "121"

output = barcode(7);
console.log(output); // "1213121"

output = barcode(20);
console.log(output); // "12131231321231213123"
```

<br/>
<br/>
<br/>

# 🤔 나의 생각

<br/>


<br/>
<br/>

> code
---

<br/>

```js

```


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

## 🙌 느낀점

<br/>

평소에 프로그래머스 3단계 문제들을 풀면서 BFS에 대해서 어느정도 공부를 해놔서 이 문제를 겨우겨우 풀 수 있었다.. BFS 구현 코드는 거의 다 비슷해서 이제는 BFS 문제들의 코드들은 다 비슷하게 보인다.

배운대로 잘 풀 수 있어서 정말 좋았다!!
<br/>
<br/>
<br/>

> 👊 **내일의 TIW(today I Will)**

Greedy, DFS

