---
layout: post
title: "Stack/Queue, Binary Search 알고리즘"
subtitle: "📅 TIL #40"
toc: true
toc_sticky: true
toc_label: "페이지 주요 목차"
date: 2021-03-06
background: "/img/posts/post-TIL.png"
tags: [TIL, immersive-course, Algorithm]
---

<br/>
<br/>

# <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">🎯 Achievement Goals</span>

<br/>
* 프로그래머스 Lv2. 기능개발
* 프로그래머스 Lv2. 다리를 건너는 트럭
* 프로그래머스 Lv3. 입국심사 

<br/>
<br/>
<br/>



## 👉 Lv2. 기능개발

<br/>

## 문제 설명

프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.

또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.

먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.

<br/>
<br/>

## 제한사항

* 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.
* 작업 진도는 100 미만의 자연수입니다.
* 작업 속도는 100 이하의 자연수입니다.
* 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.

<br/>
<br/>

## 입출력 예

|progresses|speeds|return|
|:------|:---|:---|
|[93, 30, 55]|[1, 30, 5]|[2, 1]|
|[95, 90, 99, 99, 80, 99]|[1, 1, 1, 1, 1]|[1, 3, 2]|

<br/>
<br/>

## 입출력 예 설명

<br/>
입출력 예 #1 <br/>
첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.

두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.

세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.

따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.

<br/>
입출력 예 #2 <br/>
모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.

따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.

<br/>
<br/>
<br/>

# 🤔 나의 생각

<br/>
* 가장 먼저 각 기능마다 며칠 뒤에 배포할 수 있는지 배열 형태로 구한다.
* 그리고 배열의 첫번째를 기준으로 삼는다.
* 각 작업마다 배포가 가능한 일수를 담아놓은 배열을 반복문으로 순회한다.
* 만약 첫번째보다 그 다음 기능이 더 늦게 끝난다면 첫번째 기능은 배포가 가능하기 때문에 바로 <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">배포(deploy)</span>를 해준다. 배포는 빈 배열에 <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">push</span>를 해준다.
* 배포를 한 후 기준을 삼았던 첫번째 배열은 빈 배열에 저장해놓고, 첫번째 배열은 그 다음 배열로 <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">재할당</span>하면서 배포한 기능은 <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">삭제처리</span>한다.
* 배포할 때마다 일수에 맞게 묶어서 배포하기 때문에, 카운트를 세줘야 하는데 배포를 했을 경우는 <span style ="background-color:#4e5357; color:#f2b810; border-radius:4px; padding:2px">cnt = 1 (카운터 초기화)</span>를 해주면 된다.
* 배포를 해야하는데 다음 기능이 아직 작업 일수를 채우지 못했다면 그대로 카운터를 세준다.
* 값을 저장해뒀던 빈 배열을 리턴한다.

<br/>
<br/>

> code
---

<br/>

```js
function solution(progresses, speeds) {
  let answer = [];
  let days = Math.map((el, idx) => Math.ceil((100 - el) / speeds[idx]));
  let front = days[0];
  let cnt = 1;

  for (let i = 1; i < days.length; i++) {
    if (front >= days[i]) {
      cnt++;
    }
    else {
      answer.push(cnt);  // 배포
      front = days[i];   // 배포 후 삭제처리
      cnt = 1            // 카운터 초기화
    }
  }
  answer.push(cnt);
  return answer;
}
```

<br/>
<br/>
<br/>

## 👉 Lv2. 다리를 지나는 트럭

<br/>

## 문제 설명

트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.
※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.

예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.

|경과시간| 다리를 지난 트럭| 다리를 건너는 트럭| 대기 트럭|
|:------|:---|:---|:---|
|0|[]|[]|[7,4,5,6]|
|1~2|[]|[7]|[4,5,6]|
|3|[7]|[4]|[5,6]|
|4|[7]|[4,5]|[6]|
|5|[7,4]|[5]|[6]|
|6~7|[7,4,5]|[5]|[6]|
|8|[7,4,5,6]|[]|[]|

따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.

solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.

<br/>
<br/>

## 제한사항

* bridge_length는 1 이상 10,000 이하입니다.
* weight는 1 이상 10,000 이하입니다.
* truck_weights의 길이는 1 이상 10,000 이하입니다.
* 모든 트럭의 무게는 1 이상 weight 이하입니다.

<br/>
<br/>

## 입출력 예

|bridge_length|weight|truck_weights|return|
|:------:|:---:|:---:|:---:|
|2|10|[7,4,5,6]|8|
|100|100|[10]|101|
|100|100|[10,10,10,10,10,10,10,10,10,10]|110|

<br/>
<br/>

# 🤔 나의 생각

<br/>
* 나는 가장 먼저 다리의 길이만큼 다리를 0으로 채워서 배열을 만들었다.
* 그리고 다리를 건널 때 마다 시간을 체크해야 하기 때문에 반복문 루프를 돌 때마다 계속 카운트를 세어주었다.
* 그와 동시에, 다리 맨앞은 제거해주면서 트럭을 하나씩 집어넣었다.
* 트럭의 무게가 다리의 무게를 초과할 경우는 시간만 세어주었고, 트럭이 다리를 건널 수 있을 때는 다리에 트럭을 하나씩 넣어주었다.

파이썬으로 풀었을 때는 sum함수가 기본적으로 내장되어 있어서 편하게 풀었는데 자바스크립트에서는 sum 함수를 만들어야 했었고, 만들어서 푸니까 실행속도가 엄청 느렸다. ㅠㅠ

<br/>
<br/>

> code
---

<br/>

```js
function solution(bridge_length, weight, truck_weights) {    
    // [0,0]
    let bridge = new Array(bridge_length).fill(0);
    let time = 0;

    let sum = () => {
        let result = 0;
        for (let i = 0; i < bridge.length; i++) {
            result += bridge[i];
        }
        return result;
    }

    while (bridge) {
        time++;
        bridge.shift();
        
        if (sum() + truck_weights[0] <= weight) {
            bridge.push(truck_weights.shift());
        }
        else {
            bridge.push(0);
            if (sum() === 0) {
                break;
            }
        }
    }

    return time;
}
```

<br/>
<br/>
<br/>

## 👉 Lv3. 입국 심사

<br/>
<br/>

## 문제 설명

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

<br/>
<br/>

## 제한사항

* 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
* 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
* 심사관은 1명 이상 100,000명 이하입니다.

<br/>
<br/>

## 입출력 예

|n|times|return|
|:------:|:---:|:---:|
|6|[7, 10]|28|

<br/>
<br/>

## 입출력 예 설명

가장 첫 두 사람은 바로 심사를 받으러 갑니다.

7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.

10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.

14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.

20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.

<br/>
<br/>

# 🤔 나의 생각

<br/>
* 가장 오래 걸렸을 경우의 시간과, 가장 적은 시간을 먼저 구한다.
* 그리고 이분 탐색을 하기 위해 중간 값을 구한다.
* 심사관마다 걸리는 시간을 하나씩 순회하면서 각 분마다 mid분 동안 몇 명이 심사 받을 수 있는지 확인한다.<br/>
예를 들어, times[i] = 7, mid = 30 이라면 7분마다 심사위원이 30분동안 4명을 검사할 수 있는 것이다.

* 이런식으로 min이 max 같거나 클 때까지 반복문을 돌아준다.
* 분마다 검사하는데 걸리는 시간을 최솟값으로 나타낸다.

<br/>
<br/>

> code
---

<br/>

```js
function solution(n, times) {
    // 가장 오래 걸리는 시간
    let max = n * times[times.length-1];
    let min = 1;
    let answer = max;
    
    while(min <= max) {
        let cnt = 0;
        let mid = parseInt((max + min) / 2);
        
        for (let i = 0; i <= times.length; i++) {
            // times[i]분 마다 검사할 수 있는 인원 수
            cnt += parseInt(mid / times[i]);
            if (cnt >= n) {
                // 최솟값 찾아내기
                answer = Math.min(mid, answer);
                break;
            }
        }
        if (cnt >= n) {
            max = mid - 1;
        }
        else {
            min = mid + 1;
        }
    }
    return answer;
}
```

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

## 🙌 느낀점

<br/>
프로그래머스 1단계를 다 풀고 이제 겨우겨우 2단계를 풀어나가고 있는 단계에서 3단계를 풀려고 하니 정말 벅찼다 ㅠㅠ 한 문제를 가지고 몇 시간동안 고민하는 건 기본이였다.. 풀고 나서도 다음 날되면 다시 또 풀 수 있을까? 걱정이 된다..

알고리즘은 날마다 1시간 ~ 2시간씩 투자해서 매일 매일 풀어주고 있는데도 아직 많이 부족하다. 더 열심히 풀어봐야겠다.




<br/>
<br/>
<br/>

> 👊 **내일의 TIW(today I Will)**

그래프, BFS

